import bcrypt from "bcrypt";

export default function login_2fa(server) {
	const opts = {
		schema: {
			description: "Sends the 2fa code to be verified",
			tags: ["auth"],
			querystring: {
				type: "object",
				required: ["token"],
				properties: {
					token: {
						type: "string",
						description: "Token generated by the login endpoint",
						example: "a3f9c8e2b4d74e0c9f...",
					},
				},
			},
			body: {
				type: "object",
				required: ["code"],
				properties: {
					code: { type: "string", minLength: 6, maxLength: 6 },
				},
			},
		},
	};
	server.post("/login/2fa", async (req, reply) => {
		const { code } = req.body;
		const twoFaToken = req.query.token;

		const user = db.prepare("SELECT code_hash_2fa, code_expires_2fa, id FROM users WHERE token_2fa = ?").get(twoFaToken);
		if (!user) {
			return reply.status(401).send({ error: "Unauthorized", message: "Invalid token" });
		}
		if (user.code_expires_2fa < Date.now()) {
			return reply.status(401).send({ error: "Unauthorized", message: "Code expired" });
		}
		const inputHash = crypto.createHmac("sha256", process.env.OTP_SECRET).update(code).digest("hex");

		if (inputHash !== user.code_hash_2fa) {
			return reply.status(401).send({ error: "Unauthorized", message: "Invalid code" });
		}
		db.prepare(`UPDATE users SET code_hash_2fa = null, code_expires_2fa = null, token_2fa = null WHERE id = ?`).run(user.id);
		return reply.status(200).send({ success: true, message: "Acess granted!" });
	});
}
